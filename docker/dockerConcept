Docker使用Google公司推出的Go语言进行开发实现,基于Linux内核的cgroup,namespace,
以及AUFS类的Union FS等技术,对进程进行封装隔离,属于操作系统层面的虚拟化技术。

Docker包括三个基本概念:镜像(Image) 容器(Container) 仓库(Repository)

Docker镜像是一个特殊的文件系统,除了提供容器运行时所需的程序、库、资源、配置等文件外,
还包含了一些为运行时准备的一些配置参数(如匿名卷、环境变量、用户等)。
镜像不包含任何动态数据,其内容在构建之后也不会被改变。

镜像(Image)和容器(Container)的关系,就像是面向对象程序设计中的类和实例一样,
镜像是静态的定义,容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

容器的实质是进程

镜像使用的是分层存储

每一个容器运行时,是以镜像为基础层,在其上创建一个容器存储层,为容器运行时读写而准备的。

启动容器就是启动主进程

容器存储层的生存周期和容器一样,容器消亡时,容器存储层也随之消亡。
因此,任何保存于容器存储层的信息都会随容器删除而丢失。

一个Docker Registry中可以包含多个仓库(Repository);每个仓库可以包含多个标签(Tag);
每个标签对应一个镜像。

镜像是多层存储,每一层是在前一层的基础上进行的修改;
而容器同样也是多层存储,是在以镜像为基础层,在其基础上加一层作为容器运行时的存储层

当利用docker run来创建容器时,Docker在后台运行的标准操作包括:
1.检查本地是否存在指定的镜像,不存在就从公有仓库下载
2.利用镜像创建并启动一个容器
3.分配一个文件系统,并在只读的镜像层外面挂载一层可读写层
4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去
5.从地址池配置一个 ip 地址给容器
6.执行用户指定的应用程序
7.执行完毕后容器被终止

Docker在容器中管理数据主要有两种方式:1.Data volumes 2.Data volume containers

数据卷是一个可供一个或多个容器使用的特殊目录
数据卷可以在容器之间共享和重用
对数据卷的修改会立马生效
对数据卷的更新,不会影响镜像
数据卷默认会一直存在,即使容器被删除

注意:数据卷的使用,类似于Linux下对目录或文件进行mount,
镜像中的被指定为挂载点的目录中的文件会隐藏掉,能显示看的是挂载的数据卷。

数据卷是被设计用来持久化数据的,它的生命周期独立于容器,Docker不会在容器被删除后自动删除数据卷,
并且也不存在垃圾回收这样的机制来处理没有任何容器引用的数据卷。

当Docker启动时,会自动在主机上创建一个docker0虚拟网桥,实际上是Linux的一个bridge。
它会在挂载到它的网口之间进行转发。

当创建一个Docker容器的时候,同时会创建了一对veth pair接口(当数据包发送到一个接口时,
另外一个接口也可以收到相同的数据包)。

容器的网络拓扑是否已经互联。默认情况下,所有容器都会被连接到docker0网桥上。
本地系统的防火墙软件 --iptables是否允许通过。

容器所有到外部网络的连接,源地址都会被NAT成本地系统的IP地址.
这是使用的iptables源地址伪装操作实现的.

默认情况下,Docker会将所有容器连接到由docker0提供的虚拟子网中。

Docker的安全性时,主要考虑三个方面:
由内核的命名空间和控制组机制提供的容器内在安全
Docker 程序(特别是服务端)本身的抗攻击性
内核安全性的加强机制对容器安全性的影响

底层实现
Docker底层的核心技术包括Linux上的命名空间(Namespaces)、控制组(Controlgroups)、
Union文件系统(Union file systems)和容器格式(Container format)

Docker采用了C/S架构,包括客户端和服务端.Docker daemon作为服务端接受来自客户的请求,
并处理这些请求(创建、运行、分发容器)。

联合文件系统是Docker镜像的基础

Docker-Compose:定义和运行多个Docker容器的应用(Defining and running multi-container Docker applications)

Compose 中有两个重要的概念:
1.服务(service):一个应用的容器,实际上可以包括若干运行相同镜像的容器实例。
2.项目(project):由一组关联的应用容器组成的一个完整业务单元,在docker-compose.yml文件中定义。
可见,一个项目可以由多个服务(容器)关联而成,Compose面向项目进行管理。

Compose 的默认管理对象是项目,通过子命令对项目中的一组容器进行便捷地生命周期管理。






